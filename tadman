#! /usr/bin/python3

""" This is the main script for the Tadman Package Manager.
"""
## Standard
import os
import subprocess
import sys
## Scripts
import tad_autotools.processor as aproc
import tad_autotools.reader as aread
import tad_autotools.writer as awrite
import tad_cmake.processor as cproc
import tad_cmake.reader as cread
import tad_cmake.writer as cwrite
import tad_interface.gtk_main as tad_build
import tad_interface.gtk_install as tad_install
import tad_tools.config_build as config_build
import tad_tools.symbolic_linker as sym_linker
import tad_tools.path_tools as path_tools
import tad_tools.logger as log

def get_autotools_options(a_path):
    build_type = 'autotools'
    config_out_file_path = "%s/configure" % a_path

    if os.path.isfile(config_out_file_path):
        print("Previous config_out.txt found!")
    else:
        awrite.write_config_txt(a_path)

    raw_options_list = aread.make_options_list(config_out_file_path)
    filtered_options_list = aproc.autotool_newer_processor(raw_options_list)

    return build_type, filtered_options_list

def get_cmake_options(a_path):
    build_type = 'cmake'
    config_out_file_path = "%s/config_out.txt" % a_path
    print("WARNING: Program dependencies required prior to config!",
          file=sys.stderr)

    if os.path.isfile(config_out_file_path):
        print("Previous config_out.txt found!")
    else:
        cwrite.write_config_txt(a_path)

    raw_options_list = cread.make_options_list(config_out_file_path)
    filtered_options_list = cproc.cmake_processor(raw_options_list)

    return build_type, filtered_options_list

def get_autogen_options(a_path):
    build_type = 'autotools'
    config_out_file_path = "%s/config_out.txt" % a_path

    os.chdir(a_path)
    subprocess.run(['./autogen.sh'])
    awrite.write_config_txt(a_path)
    raw_options_list = aread.make_options_list(config_out_file_path)
    filtered_options_list = aproc.autotool_newer_processor(raw_options_list)

    return build_type, filtered_options_list

def find_build_type(a_path):
    if os.path.isfile("%s/configure" % a_path):
        option_list = get_autotools_options(a_path)
    elif os.path.isfile("%s/CMakeLists.txt" % a_path):
        option_list = get_cmake_options(a_path)
    elif os.path.isfile("%s/autogen.sh" % a_path):
        option_list = get_autogen_options(a_path)

    return option_list

def configure_package(a_path):

    package_name, package_version = path_tools.name_version_split(a_path)
    package_title = "%s-%s" % (package_name, package_version)

    build_type, options_list = find_build_type(a_path)
    interface = tad_build.MainInterface(options_list, package_name,
                                        package_version, build_type)
    interface.show_all()
    Gtk.main()

    return_values = interface.get_return_values()
    package_name = return_values[0]
    package_version = return_values[1]
    selected_options = return_values[2]
    if selected_options == []:
        print("Tadman exited.")
        sys.exit(0)

    # Create list of the configuration options which can be used by subprocess
    configuration = config_build.configure_maker(options_list,
                                                 selected_options,
                                                 build_type)
    package_destination = "%s/%s" % ("/usr/local/tadman",
                                     "%s-%s" % (package_name, package_version)

    return configuration, package_destination

def build_package(in_path, out_path, config_options):
    # Change directories to the source directory
    os.chdir(in_path)
    print("changed to %s" % in_path)
    # Configure the sources
    subprocess.run(config_options)
    # Build the sources
    subprocess.run(['make', '-j', '4'])
    # Install it in the Tadman directory
    subprocess.run(['make', "DESTDIR=%s" % out_path, 'install'])

def print_help_message():

    arg_dict = {'build': "Build the package from source code",
                'help': "Print this help message",
                'install': "Use the symlink manager to install the package",
                'uninstall': "Destroy all previously created symlinks",
                'version': "Print version info"}

    print("Usage: tadman [ARGUMENT] [PATH]\n\nArguments:")

    for argument in sorted(arg_dict):
        print("    %s\t%s" % (argument, arg_dict[argument]))

def install_package(a_path):
    print("Installing")
    sym_linker.sym_farm(a_path)
    log.install_logger(a_path, 'Install')

# The real script is here
try:
    argument = sys.argv[1]
    pack_path = path_tools.last_slash_check(sys.argv[2])

    # Check for root user
    if os.geteuid() != 0:
        print("Only root can execute this command")
        sys.exit(1)

    # Run something based on the argument
    if argument == 'build':
        print("Building")
        config_list, pack_dest = configure_package(pack_path)
        build_package(pack_path, pack_dest, config_list)
        log.build_logger(pack_dest)

        if tad_install.gui_main(pack_path):
            install_package(pack_path)

    elif argument == 'install':
        install_package(pack_path)

    elif argument == 'uninstall':
        print("Uninstalling")
        sym_linker.sym_reap(pack_path)
        log.install_logger(pack_path, 'Uninstall')

    else:
        print("Invalid argument passed")
        print_help_message()

except IndexError:
    try:
        if sys.argv[1] == 'version':
            print('Tadman 0.0.3')
        else:
            raise IndexError
    except IndexError:
        print_help_message()
