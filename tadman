#! /usr/bin/python3

## Standard
import os
import subprocess
import sys
## Dependencies
# N/A
## Scripts
import tad_autotools.processor as aproc
import tad_autotools.reader as aread
import tad_autotools.writer as awrite
import tad_cmake.processor as cproc
import tad_cmake.reader as cread
import tad_cmake.writer as cwrite
import tad_interface.gtk_main as tad_gui
import tad_tools.config_build as config_build
import tad_tools.name_split as name_split
import tad_tools.symbolic_linker as sym_linker

def build_package(a_path):

    # Package info which can be gathered from the path name
    package_name, package_version = name_split.name_version_split(a_path)
    package_title = "%s-%s" % (package_name, package_version)

    # Paths defining where some files may be.
    autogen_file_path = "%s/autogen.sh" % a_path
    cmakelists_file_path = "%s/CMakeLists.txt" % a_path
    configure_file_path = "%s/configure" % a_path

    # Where the file with all options should be output to
    config_out_file_path = "%s/config_out.txt" % a_path

    # Find out what type of build is available 
    if os.path.isfile(configure_file_path):

        build_type = 'autotools'

        if os.path.isfile(config_out_file_path):
            print("Previous config_out.txt found!")
        else:
            awrite.write_config_txt(path)

        raw_options_list = aread.make_options_list(config_out_file_path)
        filtered_options_list = aproc.autotool_new_processor(raw_options_list)

    elif os.path.isfile(cmakelists_file_path):

        build_type = 'cmake'
        
        print("WARNING: Program dependencies required prior to config!", 
              file=sys.stderr)

        if os.path.isfile(config_out_file_path):
            print("Previous config_out.txt found!")
        else:
            cwrite.write_config_txt(path)
        
        raw_options_list = cread.make_options_list(config_out_file_path)
        filtered_options_list = cproc.cmake_processor(raw_options_list)

    elif os.path.isfile(autogen_file_path):

        build_type = 'autotools'
        
        os.chdir(path)
        subprocess.run(['./autogen.sh'])
        awrite.write_config_txt(path)
        raw_options_list = aread.make_options_list(config_out_file_path)
        filtered_options_list = aproc.autotool_new_processor(raw_options_list)

    else:
        print("This directory does not have a configure file")
        sys.exit(97)
 
    # Start the GTK-based GUI
    interface = tad_gui.gui_main(build_type, package_name, 
                                 package_version, filtered_options_list)
    
    # If the GUI was exited
    if interface == []:
        print("Tadman exited.")
        sys.exit(0)
    
    # Create list of the configuration options which can be used by subprocess
    configuration = config_build.configure_maker(build_type, interface)
    updated_title = "%s-%s" % (interface[0], interface[1])
    package_destination = "%s%s" % ("/usr/local/tadman/", updated_title)
    # Change directories to the source directory
    os.chdir(a_path)
    print("changed to %s" % a_path)
    # Configure the sources
    subprocess.run(configuration)
    # Build the sources
    subprocess.run(['make', '-j', '9'])
    # Install it in the Tadman directory
    install_directory_flag = "DESTDIR=/usr/local/tadman/%s" % updated_title
    subprocess.run(['make', install_directory_flag, 'install'])

def print_help_message():
    print("Usage: tadman [ARGUMENT] [PATH_OR_NAME]")


def main_thing(argument, a_path):

    if os.geteuid() != 0:
        print("Only root can execute this command")
        sys.exit(1)

    if argument == 'build':
        print("Building")
        build_package(a_path)
    elif argument == 'install':
        print("Installing")
        sym_linker.sym_farm(a_path)
    elif argument == 'uninstall':
        print("Uninstalling")
        sym_linker.sym_reap(a_path)
    else:
        print("Invalid argument passed")
        print_help_message()

# Here is the actual script, isn't it cute? :D
try:
    arg = sys.argv[1]
    path = sys.argv[2]

    main_thing(arg, path)
except IndexError:
    print_help_message()
